<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christof Claessens">
<meta name="dcterms.date" content="2025-06-01">

<title>Attention mechanics – TinyLM - language model learnings</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ac0c8ed2d1cf15fa6d1cdb3d13a148cc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notebooks/01-Tokenizing.html">Notebooks</a></li><li class="breadcrumb-item"><a href="../notebooks/02-Attention.html">Attention</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">TinyLM - language model learnings</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Getting Started</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../theory/softmax.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Softmax Function</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../theory/cross-entropy-loss.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cross Entropy Loss</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Notebooks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/01-Tokenizing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tokenization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/02-Attention.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Attention</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#self-attention" id="toc-self-attention" class="nav-link active" data-scroll-target="#self-attention"><span class="header-section-number">1</span> Self-Attention</a>
  <ul class="collapse">
  <li><a href="#simplified-self-attention" id="toc-simplified-self-attention" class="nav-link" data-scroll-target="#simplified-self-attention"><span class="header-section-number">1.1</span> Simplified Self-Attention</a>
  <ul class="collapse">
  <li><a href="#attention-scores" id="toc-attention-scores" class="nav-link" data-scroll-target="#attention-scores"><span class="header-section-number">1.1.1</span> Attention scores</a></li>
  <li><a href="#normalizing" id="toc-normalizing" class="nav-link" data-scroll-target="#normalizing"><span class="header-section-number">1.1.2</span> Normalizing</a></li>
  <li><a href="#context-vector" id="toc-context-vector" class="nav-link" data-scroll-target="#context-vector"><span class="header-section-number">1.1.3</span> Context Vector</a></li>
  <li><a href="#all-context-vectors" id="toc-all-context-vectors" class="nav-link" data-scroll-target="#all-context-vectors"><span class="header-section-number">1.1.4</span> All context vectors</a></li>
  </ul></li>
  <li><a href="#self-attention-with-trainable-weights" id="toc-self-attention-with-trainable-weights" class="nav-link" data-scroll-target="#self-attention-with-trainable-weights"><span class="header-section-number">1.2</span> Self-Attention with trainable weights</a>
  <ul class="collapse">
  <li><a href="#single-context-vector" id="toc-single-context-vector" class="nav-link" data-scroll-target="#single-context-vector"><span class="header-section-number">1.2.1</span> Single context vector</a></li>
  <li><a href="#why-scaling" id="toc-why-scaling" class="nav-link" data-scroll-target="#why-scaling"><span class="header-section-number">1.2.2</span> Why scaling?</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notebooks/01-Tokenizing.html">Notebooks</a></li><li class="breadcrumb-item"><a href="../notebooks/02-Attention.html">Attention</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Attention mechanics</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Christof Claessens </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In the previous notebook we prepared and massaged our text into input vectors that encode both tokens as well as their positions. It’s these input vectors that will be handled by the rest of the model.</p>
<section id="self-attention" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Self-Attention</h1>
<p>Self-Attention is a technique whereby each position in the input sequence can consider the relevancy of each other position in the same sequence when the representation for the sequence is being computed. (Traditional “attention”, as opposed to self-attention look at relations between two different sequences, input- and output, as opposed as using a single sequence.)</p>
<section id="simplified-self-attention" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="simplified-self-attention"><span class="header-section-number">1.1</span> Simplified Self-Attention</h2>
<p>Let’s take a simple sentence: “I am learning this”</p>
<p>This is our input sequencen let’s call it <span class="math inline">\(x\)</span> with 4 tokens: <span class="math inline">\(x^{(1)}\)</span>, <span class="math inline">\(x^{(2)}\)</span>, <span class="math inline">\(x^{(3)}\)</span> and <span class="math inline">\(x^{(4)}\)</span>.</p>
<p>In general if our context length is <span class="math inline">\(T\)</span> then we have <span class="math inline">\(x^{(1)} \ldots x^{(T)}\)</span></p>
<p>Each <span class="math inline">\(x^{(i)}\)</span> is a <span class="math inline">\(d\)</span>-dimensional embedding vector representing a token.</p>
<p>Now we will calculate a context vector <span class="math inline">\(z^{i}\)</span> for each <span class="math inline">\(x^{i}\)</span>. This vector will contain information from all vectors <span class="math inline">\(x^{(1)} \ldots x^{(T)}\)</span></p>
<section id="attention-scores" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="attention-scores"><span class="header-section-number">1.1.1</span> Attention scores</h3>
<p>So, for example, for <span class="math inline">\(x^{(3)}\)</span> we’ll calculate a context vector <span class="math inline">\(z^{(3)}\)</span>. We’ll call <span class="math inline">\(x^{(3)}\)</span> our “query” vector and for this query we’ll calculate an attention score for each of the tokens in our sentence: for example <span class="math inline">\(w_{31}\)</span> for the attention score between our query (the 3rd token) and the first token. In this way we’ll have: <span class="math inline">\(w_{31}\)</span>, <span class="math inline">\(w_{32}\)</span>, <span class="math inline">\(w_{33}\)</span> and <span class="math inline">\(w_{34}\)</span></p>
<p>The attention score <span class="math inline">\(w_{31}\)</span> is the dot product from the third token with the first token. So if: <span class="math display">\[ x^{(3)} = [0.2,0.7,0.9] \text{  (representing the token "learning")} \]</span> <span class="math display">\[ x^{(1)} = [0.8,0.9,0.3] \text{  (representing the token "I")} \]</span></p>
<p>Then:</p>
<p><span class="math display">\[w_{(31)} = x^{(3)} \cdot x^{(1)} = [(.2*.8) + (.7*.9) + (.9 * .3)] = 1.06 \]</span></p>
<p>We’ll do this between our query <span class="math inline">\(x^{(3)}\)</span> and each of our <span class="math inline">\(x^{(1)},x^{(2)},x^{(3)},x^{(4)}\)</span> which result in an attention vector <span class="math inline">\(w_3 = [ w_{(31)},w_{(32)},w_{(33)},w_{(34)} ]\)</span></p>
<p>Now in python, using an input vector of our 4 tokens, each with an embedding dimension of 3:</p>
<div id="87225baa" class="cell" data-execution_count="24">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.8823, 0.9150, 0.3829],
        [0.9593, 0.3904, 0.6009],
        [0.2566, 0.7936, 0.9408],
        [0.1332, 0.9346, 0.5936]])</code></pre>
</div>
</div>
<p>We’ll calculate the attention vector for <span class="math inline">\(x^{(3)}\)</span> as our query:</p>
<div id="df259370" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> inputs[<span class="dv">2</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>attention_score_for_x3 <span class="op">=</span> torch.empty((<span class="dv">4</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, xi <span class="kw">in</span> <span class="bu">enumerate</span>(inputs):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the attention score for x3i</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    attention_score_for_x3[i] <span class="op">=</span> torch.dot(xi, query)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_score_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([1.3127, 1.1213, 1.5807, 1.3343])</code></pre>
</div>
</div>
</section>
<section id="normalizing" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="normalizing"><span class="header-section-number">1.1.2</span> Normalizing</h3>
<p>Now that we’ve calculated the attention vector <span class="math inline">\(w_3\)</span> for query <span class="math inline">\(x^{(3)}\)</span>, we have a vector with a number for every token. These numbers however are not normalized between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, which is what we’d really like. For this, we’ll use <a href="../theory/cross-entropy-loss.html">Cross-Entropy Loss</a>, which will make sure the numbers in our attention vector add up to one and each are between <span class="math inline">\(0 \ldots 1\)</span></p>
<div id="26d7f4f9" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>attention_weights_for_x3 <span class="op">=</span> torch.softmax(attention_score_for_x3, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_weights_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.2407, 0.1987, 0.3146, 0.2459])</code></pre>
</div>
</div>
</section>
<section id="context-vector" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="context-vector"><span class="header-section-number">1.1.3</span> Context Vector</h3>
<p>So now that we have our normalized attention weights for a single query <span class="math inline">\(x^{(3)}\)</span> we can calculate the full context vector that corresponds to <span class="math inline">\(x^{(3)}\)</span></p>
<p>Our attention weights from the previous step were: <span class="math inline">\([.2, .1, .3, .2]\)</span> or more in general, a vector <span class="math inline">\([\alpha _{31}, \alpha _{32}, \alpha _{33}, \alpha _{34}]\)</span></p>
<p>To calculate the context vector for <span class="math inline">\(x^{(3)}\)</span> we’ll take each <span class="math inline">\(\alpha _{3i}\)</span> and multiply that by <span class="math inline">\(x^{(i)}\)</span>. Then we’ll add up all those vectors.</p>
<div id="68002bda" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> inputs[<span class="dv">2</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>context_vector_for_x3 <span class="op">=</span> torch.zeros((query.shape)) <span class="co"># dimension of query (3 in this case)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, xi <span class="kw">in</span> <span class="bu">enumerate</span>(inputs):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    context_vector_for_x3 <span class="op">+=</span> attention_weights_for_x3[i] <span class="op">*</span> xi <span class="co"># z3</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(context_vector_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.5165, 0.7774, 0.6536])</code></pre>
</div>
</div>
</section>
<section id="all-context-vectors" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="all-context-vectors"><span class="header-section-number">1.1.4</span> All context vectors</h3>
<p>What we did so far is to look at how to calculate a single context vector <span class="math inline">\(z^{(3)}\)</span>, for a single token <span class="math inline">\(x^{(3)}\)</span> in our input sequence. We’ll need to make this more scalable and figure out a way to calculate <span class="math inline">\(z\)</span> for all tokens in our input sequence.</p>
<p>This means, what we have done for <span class="math inline">\(x^{(3)}\)</span> we need to do for all inputs:</p>
<div id="028b9ac1" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>attention_scores_manual <span class="op">=</span> torch.empty((<span class="dv">4</span>, <span class="dv">4</span>))  <span class="co"># for each query of the 4 inputs, calculate 4 attention scores</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, query <span class="kw">in</span> <span class="bu">enumerate</span>(inputs):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j, xi <span class="kw">in</span> <span class="bu">enumerate</span>(inputs):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        attention_scores_manual[i][j] <span class="op">=</span> torch.dot(query, xi)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention scores:"</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_scores_manual)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"for comparison, the attention scores for x3 as query:"</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_score_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>attention scores:
tensor([[1.7622, 1.4337, 1.3127, 1.1999],
        [1.4337, 1.4338, 1.1213, 0.8494],
        [1.3127, 1.1213, 1.5807, 1.3343],
        [1.1999, 0.8494, 1.3343, 1.2435]])
for comparison, the attention scores for x3 as query:
tensor([1.3127, 1.1213, 1.5807, 1.3343])</code></pre>
</div>
</div>
<p>Using <code>for</code> loops however is slow and can’t be optimized using CUDA, so let’s find a way to do the same, but to use pure tensor calculations instead. Our inputs look like the below, with 4 tokens, each with a dimension of 3</p>
<div id="b4de671a" class="cell" data-execution_count="17">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.8823, 0.9150, 0.3829],
        [0.9593, 0.3904, 0.6009],
        [0.2566, 0.7936, 0.9408],
        [0.1332, 0.9346, 0.5936]])</code></pre>
</div>
</div>
<p>We can transpose this vector, so it looks like:</p>
<div id="3ff2e719" class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.8823, 0.9593, 0.2566, 0.1332],
        [0.9150, 0.3904, 0.7936, 0.9346],
        [0.3829, 0.6009, 0.9408, 0.5936]])</code></pre>
</div>
</div>
<p>If we now take multiply these two matrices, we get:</p>
<div id="dbb777d1" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>attention_scores <span class="op">=</span> inputs <span class="op">@</span> inputs.T  <span class="co"># matrix multiplication</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inputs <span class="op">@</span> inputs.T) <span class="co"># matrix multiplication</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"for comparison, the attention scores for x3 as query:"</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_score_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1.7622, 1.4337, 1.3127, 1.1999],
        [1.4337, 1.4338, 1.1213, 0.8494],
        [1.3127, 1.1213, 1.5807, 1.3343],
        [1.1999, 0.8494, 1.3343, 1.2435]])
for comparison, the attention scores for x3 as query:
tensor([1.3127, 1.1213, 1.5807, 1.3343])</code></pre>
</div>
</div>
<p>These are just attention scores, not yet attention weights, so lets normalize them:</p>
<div id="4ac7edec" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>attention_weights <span class="op">=</span> torch.softmax(attention_scores, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># normalize the attention scores</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention weights:"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_weights)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"for comparison, the attention weights for x3 as query:"</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_weights_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>attention weights:
tensor([[0.3415, 0.2459, 0.2179, 0.1946],
        [0.3040, 0.3040, 0.2225, 0.1695],
        [0.2407, 0.1987, 0.3146, 0.2459],
        [0.2569, 0.1809, 0.2938, 0.2683]])
for comparison, the attention weights for x3 as query:
tensor([0.2407, 0.1987, 0.3146, 0.2459])</code></pre>
</div>
</div>
<p>From here we can calculate our context vectors:</p>
<div id="ba50a5fd" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>all_context_vectors <span class="op">=</span> attention_weights <span class="op">@</span> inputs  <span class="co"># matrix multiplication</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"context vectors for all inputs:"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(all_context_vectors)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"for comparison, the context vector for x3:"</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(context_vector_for_x3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>context vectors for all inputs:
tensor([[0.6191, 0.7634, 0.5991],
        [0.6395, 0.7318, 0.6090],
        [0.5165, 0.7774, 0.6536],
        [0.5113, 0.7897, 0.6428]])
for comparison, the context vector for x3:
tensor([0.5165, 0.7774, 0.6536])</code></pre>
</div>
</div>
</section>
</section>
<section id="self-attention-with-trainable-weights" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="self-attention-with-trainable-weights"><span class="header-section-number">1.2</span> Self-Attention with trainable weights</h2>
<p>From here we’ll expand to what is called “scaled dot-product attention”. Also here we’ll want to calculate context vectors (one for each of our input tokens) as a weighted sum over (some abstraction) of the inputs. There are some differences with what we’ve done so far though:</p>
<ul>
<li>instead of taking directly <span class="math inline">\(q^{(i)} = x^{(i)}\)</span> as the query vector, we’ll use a projection of <span class="math inline">\(x^{(i)}\)</span>. We do this using a trainable weight matrix <span class="math inline">\(W_q\)</span>, used to calculate our query</li>
<li>instead of taking directly the dot product of <span class="math inline">\(q^{(i)}\)</span> and each <span class="math inline">\(x^{(i)}\)</span> to calculate our attention scores and weights, we’ll do the dot product with a projection of <span class="math inline">\(x^{(i)}\)</span>. We do this using a trainable weight matrix <span class="math inline">\(W_k\)</span>, used to calculate our keys.</li>
<li>instead of calculating the weighted average using these scores with each <span class="math inline">\(x^{(i)}\)</span>, we’ll do this with a projection of <span class="math inline">\(x^{(i)}\)</span>. We do this using a trainable weight matrix <span class="math inline">\(W_v\)</span>, used to calculate our values.</li>
</ul>
<p>We’ll have trainable weight matrixes: <span class="math inline">\(W_q\)</span>, <span class="math inline">\(W_k\)</span>, <span class="math inline">\(W_v\)</span> so that the model, when trained can learn to use these to project respectively the query, key and value vectors.</p>
<section id="single-context-vector" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="single-context-vector"><span class="header-section-number">1.2.1</span> Single context vector</h3>
<p>Our token embedding vectors are of a certain dimension <code>embedding_dim = 3</code> in our example. We can choose to project these into another dimension, from 3 to 5 for example. (This is not usually done however, it’s likely kept the same.) For illustration purposes, let’s go with 5 here:</p>
<div id="2db615f5" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>d_in <span class="op">=</span> embedding_dim</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>d_out <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>W_query_1 <span class="op">=</span> torch.rand((d_in, d_out))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>W_key_1 <span class="op">=</span> torch.rand((d_in, d_out))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>W_value_1 <span class="op">=</span> torch.rand((d_in, d_out))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now use <span class="math inline">\(W_q\)</span>, <span class="math inline">\(W_k\)</span>, <span class="math inline">\(W_v\)</span> to project an embedding vector from it’s normal dimension into a dimension of 5. Let’s use <span class="math inline">\(x^{(3)}\)</span> as an example for our query:</p>
<div id="6980ee82" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>x3 <span class="op">=</span> inputs[<span class="dv">2</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"x3 input:"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x3)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"W_query:"</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(W_query_1)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> x3 <span class="op">@</span> W_query_1</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"projected query:"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(query)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>x3 input:
tensor([0.2566, 0.7936, 0.9408])
W_query:
tensor([[0.1591, 0.7653],
        [0.2979, 0.8035],
        [0.3813, 0.7860]])
projected query:
tensor([0.6360, 1.5735])</code></pre>
</div>
</div>
<p>Instead of defining our projection matrices like above, we’ll define them as pytorch parameters:</p>
<div id="5938b6c2" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>W_query <span class="op">=</span> torch.nn.Parameter(W_query_1, requires_grad<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>W_key <span class="op">=</span> torch.nn.Parameter(W_key_1, requires_grad<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>W_value <span class="op">=</span> torch.nn.Parameter(W_value_1, requires_grad<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s calculate our key and value vectors for every input token in our sentence “I am learning this”: <span class="math inline">\(x^{(1)}\)</span>: “I”, <span class="math inline">\(x^{(2)}\)</span>: “am”, <span class="math inline">\(x^{(3)}\)</span>: “learning”, <span class="math inline">\(x^{(4)}\)</span>: “this”,</p>
<div id="b833c4d4" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> inputs <span class="op">@</span> W_value</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"values:"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(values)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> inputs <span class="op">@</span> W_key</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"keys:"</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(keys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>values:
tensor([[1.0811, 1.1212],
        [1.0958, 0.6997],
        [0.7121, 1.0991],
        [0.5263, 1.1051]])
keys:
tensor([[0.8380, 1.0783],
        [0.5856, 0.9536],
        [0.8969, 1.2950],
        [0.8457, 1.0728]])</code></pre>
</div>
</div>
<p>Now we can calculate the attention scores, for our query vector that got projected from <span class="math inline">\(x^{(3)}\)</span></p>
<div id="55f57929" class="cell" data-execution_count="37">
<div class="cell-output cell-output-stdout">
<pre><code>query projection from x3:
tensor([0.6360, 1.5735])</code></pre>
</div>
</div>
<p>The attention score <span class="math inline">\(w_{31}\)</span> is:</p>
<div id="51c04b8f" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> inputs[<span class="dv">0</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"x1 input:"</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x1)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"key projection from x1: "</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> x1 <span class="op">@</span> W_key</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(key)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"... which is the same as: "</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(keys[<span class="dv">0</span>])  <span class="co"># keys[0] is the key for x1</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention score between our query and x1's projected key:"</span>)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>attention_score_x3_x1 <span class="op">=</span> query.dot(key)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_score_x3_x1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>x1 input:
tensor([0.8823, 0.9150, 0.3829])
key projection from x1: 
tensor([0.8380, 1.0783])
... which is the same as: 
tensor([0.8380, 1.0783])
attention score between our query and x1's projected key:
tensor(2.2296)</code></pre>
</div>
</div>
<p>In the same way as we got the attention score between the query and x1, we can get all attention scores for our query like this:</p>
<div id="c8599d0e" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>attention_scores_x3_as_query <span class="op">=</span> query <span class="op">@</span> keys.T</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention scores for x3 as query:"</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_scores_x3_as_query)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>attention scores for x3 as query:
tensor([2.2296, 1.8729, 2.6081, 2.2259])</code></pre>
</div>
</div>
<p>As is shown above, for our chosen query, we’ll end up with 4 attention scores: one for each input token. Like before, we’ll want to normalize our attention scores into attention weights but instead of doing a pure softmax function, we’ll first scale the attention scores by dividing them by the square root of the dimension of our projected keys (2 in this case).</p>
<div id="ee0dbd7a" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"dimension of our projected key: "</span>, d_out)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>scaled_attention_weights_x3_as_query <span class="op">=</span> <span class="op">\</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  torch.softmax(attention_scores_x3_as_query <span class="op">/</span> d_out<span class="op">**</span><span class="fl">0.5</span>, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"scaled attention weights for x3 as query:"</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(scaled_attention_weights_x3_as_query)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>dimension of our projected key:  2
scaled attention weights for x3 as query:
tensor([0.2450, 0.1904, 0.3202, 0.2444])</code></pre>
</div>
</div>
</section>
<section id="why-scaling" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="why-scaling"><span class="header-section-number">1.2.2</span> Why scaling?</h3>
<p>As the dimension for our projected key vector grows, the dot products can become large numbers. An example:</p>
<div id="d45e5e84" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>key_dim <span class="op">=</span> key.shape[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"dimension of the key: "</span>, key_dim)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>W_k_for_small_output_dim <span class="op">=</span> torch.rand(key_dim, <span class="dv">2</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>W_q_for_small_output_dim <span class="op">=</span> torch.rand(key_dim, <span class="dv">2</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>W_k_for_large_output_dim <span class="op">=</span> torch.rand(key_dim, <span class="dv">64</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>W_q_for_large_output_dim <span class="op">=</span> torch.rand(key_dim, <span class="dv">64</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>projected_small_key <span class="op">=</span> key <span class="op">@</span> W_k_for_small_output_dim</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>projected_small_query <span class="op">=</span> query <span class="op">@</span> W_q_for_small_output_dim</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>projected_large_key <span class="op">=</span> key <span class="op">@</span> W_k_for_large_output_dim</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>projected_large_query <span class="op">=</span> query <span class="op">@</span> W_q_for_large_output_dim</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"projected small key:"</span>)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(projected_small_key)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"projected large key:"</span>)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(projected_large_key)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>dimension of the key:  2
projected small key:
tensor([0.6326, 0.9359])
projected large key:
tensor([0.4478, 0.7348, 1.1196, 0.9742, 1.0326, 1.0020, 1.6563, 1.0928, 0.0713,
        0.5738, 0.3447, 1.4417, 0.2443, 0.7093, 1.2625, 0.2308, 1.5117, 0.7690,
        1.2653, 0.3664, 1.1790, 1.0853, 0.9684, 1.0427, 0.7200, 0.4810, 1.0639,
        0.3090, 0.5419, 0.4283, 1.2715, 0.6433, 0.4540, 1.1592, 0.7374, 0.9412,
        1.5725, 0.7243, 1.2070, 1.0182, 0.3968, 0.6695, 0.9187, 0.7781, 1.1283,
        1.7330, 0.5940, 0.8747, 1.1336, 0.5392, 0.5872, 0.2331, 1.0088, 1.4892,
        0.6480, 0.5210, 0.7092, 1.0901, 1.2410, 1.0542, 1.3430, 1.6599, 1.3503,
        0.9442])</code></pre>
</div>
</div>
<div id="97448ac8" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>attention_scores_for_small_key <span class="op">=</span> projected_small_query <span class="op">@</span> projected_small_key.T</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention scores for small key:"</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_scores_for_small_key)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>attention_scores_for_large_key <span class="op">=</span> projected_large_query <span class="op">@</span> projected_large_key.T</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"attention scores for large key:"</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_scores_for_large_key)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>attention scores for small key:
tensor(0.8767)
attention scores for large key:
tensor(67.4447)</code></pre>
</div>
</div>
<p>See how the attention score for a large projected key dimension is so much larger?</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/xstof\.github\.io\/tinylm\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>